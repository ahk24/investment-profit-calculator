# Bilingual Investment vs. Savings Simulator: English / ÙØ§Ø±Ø³ÛŒ


def get_monthly_interest_rate(profit_percentage, profit_period):
    """
    Convert a nominal profit rate into an effective monthly rate.
    """
    rate = profit_percentage / 100
    p = profit_period.lower()
    if p == "annually":
        return (1 + rate)**(1/12) - 1
    elif p == "quarterly":
        return (1 + rate)**(1/3) - 1
    elif p == "monthly":
        return rate
    else:
        raise ValueError("Profit period must be 'monthly', 'quarterly', or 'annually'.")


def get_months_per(period):
    """
    Return how many months correspond to one period.
    """
    p = period.lower()
    if p == "monthly":
        return 1
    elif p == "quarterly":
        return 3
    elif p == "annually":
        return 12
    else:
        raise ValueError("Period must be 'monthly', 'quarterly', or 'annually'.")


def calculate_total_schedule(initial_amount, profit_percentage, profit_period, segments):
    """
    Simulate an investment with monthly compounding derived from profit_period,
    and piecewise contributions defined in `segments` list.
    Each segment is a dict with:
      - 'duration_units': length in profit_period units
      - 'amount': contribution amount each interval
      - 'period': contribution period ('monthly', 'quarterly', 'annually')
    Returns the final balance.
    """
    # Determine monthly parameters
    months_per_profit = get_months_per(profit_period)
    monthly_rate = get_monthly_interest_rate(profit_percentage, profit_period)

    # Build schedule with start/end months, amount, and interval
    schedule = []
    start_month = 1
    total_months = 0
    for seg in segments:
        seg_months = seg['duration_units'] * months_per_profit
        interval = get_months_per(seg['period'])
        schedule.append({
            'start': start_month,
            'end': start_month + seg_months - 1,
            'amount': seg['amount'],
            'interval': interval
        })
        start_month += seg_months
        total_months += seg_months

    # Simulate month-by-month
    balance = initial_amount
    for month in range(1, total_months + 1):
        # 1) Apply interest
        balance *= (1 + monthly_rate)
        # 2) Add contribution if due in the current segment
        for seg in schedule:
            if seg['start'] <= month <= seg['end']:
                if seg['amount'] > 0 and ((month - seg['start'] + 1) % seg['interval'] == 0):
                    balance += seg['amount']
                break
    return balance


# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Translations â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
translations = {
    'en': {
        'select_lang':      "Select language / Ø²Ø¨Ø§Ù† Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯ [English/Persian]: ",
        'initial_amount':   "Initial amount",
        'profit_pct':       "Profit percentage (e.g. 10 for 10%)",
        'profit_period':    "Profit period",
        'period_opts':      "(monthly/quarterly/annually)",
        'period_monthly':   "monthly",
        'period_quarterly': "quarterly",
        'period_annually':  "annually",
        'add_segments':     "Enter segment durations (in number of {profit_period}s), comma-separated",
        'segment_amounts':  "Enter contribution amounts for each segment, comma-separated",
        'segment_periods':  "Enter contribution periods for each segment (comma-separated, use monthly/quarterly/annually)",
        'output_total':     "ğŸ“ˆ Total after {total_months} months: {total:.2f} currency units",
        'output_saved':     "ğŸ’° Total if simply saved (no interest): {saved:.2f} currency units",
        'output_gain':      "ğŸ“Š Gain from investing vs. saving: {gain:.2f} currency units",
    },
    'fa': {
        'select_lang':      "Select language / Ø²Ø¨Ø§Ù† Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯ [English/Persian]: ",
        'initial_amount':   "Ù…Ø¨Ù„Øº Ø§ÙˆÙ„ÛŒÙ‡",
        'profit_pct':       "Ø¯Ø±ØµØ¯ Ø³ÙˆØ¯ (Ù…Ø«Ù„Ø§Ù‹ Û±Û° Ø¨Ø±Ø§ÛŒ Û±Û°Ùª)",
        'profit_period':    "Ø¯ÙˆØ±Ù‡ Ø³ÙˆØ¯",
        'period_opts':      "(Ù…Ø§Ù‡Ø§Ù†Ù‡/Ø³Ù‡â€ŒÙ…Ø§Ù‡Ù‡/Ø³Ø§Ù„Ø§Ù†Ù‡)",
        'period_monthly':   "Ù…Ø§Ù‡Ø§Ù†Ù‡",
        'period_quarterly': "Ø³Ù‡â€ŒÙ…Ø§Ù‡Ù‡",
        'period_annually':  "Ø³Ø§Ù„Ø§Ù†Ù‡",
        'add_segments':     "Ù…Ø¯Øªâ€ŒÙ‡Ø§ÛŒ Ù‡Ø± Ø¨Ø®Ø´ Ø±Ø§ (ØªØ¹Ø¯Ø§Ø¯ {profit_period}) Ø¨Ø§ Ú©Ø§Ù…Ø§ Ø¬Ø¯Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯",
        'segment_amounts':  "Ù…Ø¨Ø§Ù„Øº Ù‡Ø± Ø¨Ø®Ø´ Ø±Ø§ Ø¨Ø§ Ú©Ø§Ù…Ø§ Ø¬Ø¯Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯",
        'segment_periods':  "Ø¯ÙˆØ±Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø¨Ø®Ø´ Ø±Ø§ Ø¨Ø§ Ú©Ø§Ù…Ø§ Ø¬Ø¯Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (Ù…Ø§Ù‡Ø§Ù†Ù‡/Ø³Ù‡â€ŒÙ…Ø§Ù‡Ù‡/Ø³Ø§Ù„Ø§Ù†Ù‡)",
        'output_total':     "ğŸ“ˆ Ù…Ø¬Ù…ÙˆØ¹ Ù¾Ø³ Ø§Ø² {total_months} Ù…Ø§Ù‡: {total:.2f} ÙˆØ§Ø­Ø¯ Ù¾ÙˆÙ„ÛŒ",
        'output_saved':     "ğŸ’° Ù…Ø¬Ù…ÙˆØ¹ Ø§Ú¯Ø± ØµØ±ÙØ§Ù‹ Ù¾Ø³â€ŒØ§Ù†Ø¯Ø§Ø² Ù…ÛŒâ€ŒØ´Ø¯ (Ø¨Ø¯ÙˆÙ† Ø³ÙˆØ¯): {saved:.2f} ÙˆØ§Ø­Ø¯ Ù¾ÙˆÙ„ÛŒ",
        'output_gain':      "ğŸ“Š Ù…ÛŒØ²Ø§Ù† Ø§ÙØ²Ø§ÛŒØ´ Ø§Ø² Ø³Ø±Ù…Ø§ÛŒÙ‡â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ù†Ø³Ø¨Øª Ø¨Ù‡ Ù¾Ø³â€ŒØ§Ù†Ø¯Ø§Ø²: {gain:.2f} ÙˆØ§Ø­Ø¯ Ù¾ÙˆÙ„ÛŒ",
    }
}

# map user entry to internal keys
period_map = {
    'en': {'monthly': 'monthly', 'quarterly': 'quarterly', 'annually': 'annually'},
    'fa': {'Ù…Ø§Ù‡Ø§Ù†Ù‡': 'monthly', 'Ø³Ù‡â€ŒÙ…Ø§Ù‡Ù‡': 'quarterly', 'Ø³Ø§Ù„Ø§Ù†Ù‡': 'annually'}
}

# Prompt helper

def input_with_default(prompt, default, cast=str):
    line = input(f"{prompt} [default: {default}]: ").strip()
    return cast(line) if line else default

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Language Selection â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
lang_raw = input(translations['en']['select_lang']).strip().lower()
lang = 'fa' if lang_raw in ('persian', 'fa', 'farsi', 'ÙØ§Ø±Ø³ÛŒ') else 'en'
t = translations[lang]

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Gather Core Inputs â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
initial_amount    = input_with_default(t['initial_amount'], 0, float)
profit_percentage = input_with_default(t['profit_pct'], 10, float)

# Profit period selection
pp_in = input_with_default(f"{t['profit_period']} {t['period_opts']}", t['period_annually'])
profit_period     = period_map[lang].get(pp_in, pp_in)

# Segment definitions
# Durations in profit_period units, comma-separated
dur_str = input_with_default(
    t['add_segments'].format(profit_period=t['period_' + profit_period]),
    "1"
)
durations = [int(x.strip()) for x in dur_str.split(',')]

# Contribution amounts per segment
amt_str = input_with_default(t['segment_amounts'], "0")
amounts = [float(x.strip()) for x in amt_str.split(',')]
if len(amounts) == 1:
    amounts *= len(durations)
elif len(amounts) != len(durations):
    raise ValueError("Number of segment amounts must match number of durations.")

# Contribution periods per segment
per_str = input_with_default(f"{t['segment_periods']}", t['period_monthly'])
periods = [p.strip() for p in per_str.split(',')]
mapped_periods = [period_map[lang].get(p, p) for p in periods]
if len(mapped_periods) == 1:
    mapped_periods *= len(durations)
elif len(mapped_periods) != len(durations):
    raise ValueError("Number of segment periods must match number of durations.")

# Build segments list
nsegments = []
for du, am, pe in zip(durations, amounts, mapped_periods):
    nsegments.append({'duration_units': du, 'amount': am, 'period': pe})

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Calculation & Results â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# Compute final invested total
total = calculate_total_schedule(
    initial_amount,
    profit_percentage,
    profit_period,
    nsegments
)

# Compute saved-only total
months_per_profit = get_months_per(profit_period)
total_months = sum(durations) * months_per_profit
saved_contribs = 0
for seg in nsegments:
    seg_months = seg['duration_units'] * months_per_profit
    contribs = seg_months // get_months_per(seg['period'])
    saved_contribs += contribs * seg['amount']
saved_total = initial_amount + saved_contribs

gain = total - saved_total

# Outputs
print(t['output_total'].format(total_months=total_months, total=total))
print(t['output_saved'].format(saved=saved_total))
print(t['output_gain'].format(gain=gain))
